# Go 언어 연산자

Go 언어의 다양한 연산자와 그 사용법에 대해 알아보겠습니다.

## 산술 연산자

### 사칙 연산과 나머지

| 연산자 | 연산 | 피연산자 타입 |
| ---- | ---- | ---- |
| + | 덧셈 | 정수, 실수, 복소수, 문자열 |
| - | 뺄셈 | 정수, 실수, 복소수 |
| * | 곱셈 | 정수, 실수, 복소수 |
| / | 나눗셈 | 정수, 실수, 복소수 |
| % | 나머지 | 정수 |

**주의사항:**
- 정수 나눗셈은 소수점을 버립니다 (5 / 2 = 2)
- 문자열은 + 연산자로 연결할 수 있습니다

### 비트 연산

비트 연산은 정수를 이진수로 변환하여 비트 단위로 연산합니다.

| 연산자 | 연산 | 피연산자 타입 |
| ---- | ---- | ---- |
| & | AND 비트 연산 | 정수 |
| \| | OR 비트 연산 | 정수 |
| ^ | XOR 비트 연산 | 정수 |
| &^ | 비트 클리어 (AND NOT) | 정수 |

**비트 클리어(&^) 연산:**
- 오른쪽 피연산자를 먼저 NOT(^) 연산한 후 왼쪽 피연산자와 AND(&) 연산을 수행합니다
- 예: `x &^ y`는 `x & (^y)`와 같습니다

### 시프트 연산

시프트 연산은 비트를 왼쪽이나 오른쪽으로 이동시킵니다.

| 연산자 | 연산 | 피연산자 타입 |
| ---- | ---- | ---- |
| << | 왼쪽 시프트 | 정수 << 양의 정수 |
| >> | 오른쪽 시프트 | 정수 >> 양의 정수 |

#### 왼쪽 시프트(<<) 실습

왼쪽 시프트는 비트를 왼쪽으로 이동시키며, 2를 곱하는 효과가 있습니다.

```go
package main

import "fmt"

func main() {
	var x int8 = 4   // 00000100
	var y int8 = 64  // 01000000

	fmt.Printf("x:%08b x<<2:%08b x<<2: %d\n", x, x<<2, x<<2)
	fmt.Printf("y:%08b y<<2:%08b y<<2: %d\n", y, y<<2, y<<2)
}
```

실행 결과:

```bash
x:00000100 x<<2:00010000 x<<2: 16
y:01000000 y<<2:00000000 y<<2: 0
```

**결과 분석:**
- x(4)를 2칸 왼쪽 시프트하면 16이 됩니다 (4 × 2² = 16)
- y(64)를 2칸 왼쪽 시프트하면 int8 범위를 벗어나 오버플로우가 발생하여 0이 됩니다

#### 오른쪽 시프트(>>) 실습

오른쪽 시프트는 비트를 오른쪽으로 이동시키며, 2로 나누는 효과가 있습니다.

```go
package main

import "fmt"

func main() {
	var x int8 = 16
	var y int8 = -128
	var z int8 = -1
	var w uint8 = 128

	fmt.Printf("x:%08b x>>2:%08b x>>2: %d\n", x, x>>2, x>>2)
	fmt.Printf("y:%08b y>>2:%08b y>>2: %d\n", uint8(y), uint8(y>>2), y>>2)
	fmt.Printf("z:%08b z>>2:%08b z>>2: %d\n", uint8(z), uint8(z>>2), z>>2)
	fmt.Printf("w:%08b w>>2:%08b w>>2: %d\n", w, w>>2, w>>2)
}
```

실행 결과:

```bash
x:00010000 x>>2:00000100 x>>2: 4
y:10000000 y>>2:11100000 y>>2: -32
z:11111111 z>>2:11111111 z>>2: -1
w:10000000 w>>2:00100000 w>>2: 32
```

**결과 분석:**
- **양수(x)**: 오른쪽으로 밀면서 왼쪽에 0이 채워집니다
- **음수(y, z)**: 부호를 유지하기 위해 왼쪽에 1이 채워집니다 (산술 시프트)
- **부호 없는 정수(w)**: 왼쪽에 항상 0이 채워집니다 (논리 시프트)

## 비교 연산자

두 값을 비교하여 불리언(true/false)을 반환합니다.

| 연산자 | 설명 |
| ---- | ---- |
| == | 같다 |
| != | 다르다 |
| < | 작다 |
| > | 크다 |
| <= | 작거나 같다 |
| >= | 크거나 같다 |

### 정수 오버플로우

정수 타입의 최댓값을 넘어서면 최솟값으로 되돌아갑니다.

#### 오버플로우 실습

```go
package main

import "fmt"

func main() {
	var x int8 = 127  // int8의 최댓값

	fmt.Printf("%d < %d+1 : %v\n", x, x, x < x+1)
	fmt.Printf("x\t= %4d, %08b\n", x, uint8(x))
	fmt.Printf("x+1\t= %4d, %08b\n", x+1, uint8(x+1))
	fmt.Printf("x+2\t= %4d, %08b\n", x+2, uint8(x+2))
	fmt.Printf("x+3\t= %4d, %08b\n", x+3, uint8(x+3))

	var y int8 = -128  // int8의 최솟값

	fmt.Printf("%d < %d - 1 : %v\n", y, y, y < y-1)
	fmt.Printf("y\t= %4d, %08b\n", y, uint8(y))
	fmt.Printf("y-1\t= %4d, %08b\n", y-1, uint8(y-1))
}
```

실행 결과:

```bash
127 < 127+1 : false
x	=  127, 01111111
x+1	= -128, 10000000
x+2	= -127, 10000001
x+3	= -126, 10000010
-128 < -128 - 1 : true
y	= -128, 10000000
y-1	=  127, 01111111
```

**오버플로우/언더플로우 설명:**
- int8의 범위: -128 ~ 127
- 127 + 1 = -128 (오버플로우)
- -128 - 1 = 127 (언더플로우)
- 이로 인해 `127 < 127+1`이 false가 됩니다!

### 부동소수점 비교 문제

실수 연산에서는 정밀도 문제로 예상치 못한 결과가 발생할 수 있습니다.

#### 실수 비교 실습

```go
package main

import "fmt"

func main() {
	var a float64 = 0.1
	var b float64 = 0.2
	var c float64 = 0.3

	fmt.Printf("%f + %f == %f : %v\n", a, b, c, a+b == c)
	fmt.Println(a + b)
}
```

실행 결과:

```bash
0.100000 + 0.200000 == 0.300000 : false
0.30000000000000004
```

**왜 이런 일이 발생할까요?**
- 컴퓨터는 실수를 이진수로 표현합니다
- 0.1, 0.2 같은 십진수는 이진수로 정확히 표현할 수 없습니다
- 이로 인해 미세한 오차가 발생합니다

## 실수 비교의 해결 방법

### 1. 작은 오차 무시하기 (Epsilon 방식)

매우 작은 값(epsilon)보다 작은 차이는 같다고 간주하는 방법입니다.

```go
package main

import "fmt"

const epsilon = 0.00001

func equal(a, b float64) bool {
	if a > b {
		if a-b <= epsilon {
			return true
		} else {
			return false
		}
	} else {
		if b-a <= epsilon {
			return true
		} else {
			return false
		}
	}
}

func main() {
	var a float64 = 0.1
	var b float64 = 0.2
	var c float64 = 0.3

	fmt.Printf("%0.18f + %0.18f = %0.18f\n", a, b, a+b)
	fmt.Printf("%0.18f == %0.18f : %v\n", c, a+b, equal(a+b, c))

	a = 0.0000000000004
	b = 0.0000000000002
	c = 0.0000000000007

	fmt.Printf("%g == %g : %v\n", c, a+b, equal(a+b, c))
}
```

실행 결과:

```bash
0.100000000000000006 + 0.200000000000000011 = 0.300000000000000044
0.299999999999999989 == 0.300000000000000044 : true
7e-13 == 6.000000000000001e-13 : true
```

**한계점:**
- epsilon 값을 얼마로 설정할지 정하기 어렵습니다
- 매우 작은 값들을 비교할 때 부정확할 수 있습니다

### 2. math.Nextafter 사용하기

두 값이 부동소수점 표현에서 인접한지 확인하는 방법입니다.

```go
package main

import (
	"fmt"
	"math"
)

func equal(a, b float64) bool {
	return math.Nextafter(a, b) == b
}

func main() {
	var a float64 = 0.1
	var b float64 = 0.2
	var c float64 = 0.3

	fmt.Printf("%0.18f + %0.18f = %0.18f\n", a, b, a+b)
	fmt.Printf("%0.18f == %0.18f : %v\n", c, a+b, equal(a+b, c))

	a = 0.0000000000004
	b = 0.0000000000002
	c = 0.0000000000007

	fmt.Printf("%g == %g : %v\n", c, a+b, equal(a+b, c))
}
```

실행 결과:

```bash
0.100000000000000006 + 0.200000000000000011 = 0.300000000000000044
0.299999999999999989 == 0.300000000000000044 : true
7e-13 == 6.000000000000001e-13 : false
```

**Nextafter 함수:**
- `math.Nextafter(x, y)`는 x에서 y 방향으로 표현 가능한 다음 값을 반환합니다
- 두 값이 부동소수점 표현에서 바로 인접하면 true를 반환합니다

### 3. math/big 패키지 사용하기

임의의 정밀도로 연산할 수 있는 가장 정확한 방법입니다.

```go
package main

import (
	"fmt"
	"math/big"
)

func main() {
	a, _ := new(big.Float).SetString("0.1")
	b, _ := new(big.Float).SetString("0.2")
	c, _ := new(big.Float).SetString("0.3")

	d := new(big.Float).Add(a, b)

	fmt.Println(a, b, c, d)
	fmt.Println(c.Cmp(d))  // 0: 같음, -1: c < d, 1: c > d
}
```

실행 결과:

```bash
0.1 0.2 0.3 0.3
0
```

**math/big 패키지:**
- 임의의 정밀도로 실수를 표현할 수 있습니다
- 정확한 계산이 필요할 때 사용합니다
- 일반 float보다 느리고 메모리를 더 많이 사용합니다

## 논리 연산자

불리언 값을 연산하는 연산자입니다.

| 연산자 | 연산 | 설명 |
| ---- | ---- | ---- |
| && | AND | 양변이 모두 true이면 true를 반환 |
| \|\| | OR | 양변 중 하나라도 true이면 true를 반환 |
| ! | NOT | true이면 false를, false이면 true를 반환 |

**단락 평가(Short-circuit evaluation):**
- `&&`: 왼쪽이 false면 오른쪽을 평가하지 않습니다
- `||`: 왼쪽이 true면 오른쪽을 평가하지 않습니다

```go
var a int = 10
var b int = 0

// b가 0이므로 a/b를 평가하지 않아 에러 방지
if b != 0 && a/b > 1 {
    fmt.Println("OK")
}
```

## 대입 및 증감 연산자

### 대입 연산자

```go
var a int = 10

// 복합 대입 연산자
a += 5   // a = a + 5
a -= 3   // a = a - 3
a *= 2   // a = a * 2
a /= 4   // a = a / 4
a %= 3   // a = a % 3
```

### 증감 연산자

```go
var a int = 10

// 증가
a = a + 1
a += 1
a++      // 가장 간단한 형태

// 감소
a = a - 1
a -= 1
a--      // 가장 간단한 형태
```

**주의사항:**
- Go에서는 `++a`, `--a` (전위 증감) 방식을 지원하지 않습니다
- `a++`는 표현식이 아닌 문장이므로 `b = a++` 같은 사용이 불가능합니다

## 기타 연산자

| 연산자 | 설명 | 예시 |
| ---- | ---- | ---- |
| [] | 배열이나 슬라이스의 요소에 접근 | arr[0] |
| . | 구조체나 패키지의 요소에 접근 | person.name |
| & | 변수의 메모리 주솟값을 반환 | &a |
| * | 포인터가 가리키는 메모리 주소에 접근 | *ptr |
| ... | 슬라이스 요소들에 접근하거나 가변 인수 | arr... |
| : | 배열의 일부분(슬라이싱)을 추출 | arr[1:5] |
| <- | 채널에서 값을 빼거나 넣을 때 사용 | ch <- val |

## 연산자 우선순위

연산자마다 우선순위가 다릅니다. 숫자가 클수록 먼저 계산됩니다.

| 우선순위 | 연산자 |
| ---- | ---- |
| 5 (최우선) | * / % << >> & &^ |
| 4 | + - \| ^ |
| 3 | == != < <= > >= |
| 2 | && |
| 1 | \|\| |

### 우선순위 예제

```go
3 * 4 ^ 7 << 2 + 3 * 5 == 7
```

**계산 순서:**
1. 우선순위 5: `3 * 4 = 12`, `7 << 2 = 28`, `3 * 5 = 15`
   → `12 ^ 28 + 15 == 7`

2. 우선순위 4: `12 ^ 28 = 16`, `16 + 15 = 31`
   → `31 == 7`

3. 우선순위 3: `31 == 7 = false`

**가독성을 위한 괄호 사용:**
```go
(((3 * 4) ^ (7 << 2)) + (3 * 5)) == 7
```

복잡한 식에서는 괄호를 사용하여 의도를 명확히 하는 것이 좋습니다!
