# Go 언어 패키지

패키지는 Go 언어에서 코드를 구조화하는 가장 중요한 단위입니다.

## 패키지란?

**패키지(Package)**는 Go 언어에서 코드를 묶는 가장 큰 단위입니다.

**코드 조직화:**
- **함수**: 코드 블록을 묶음
- **구조체**: 데이터를 묶음
- **패키지**: 함수, 구조체, 그 외 코드를 묶음

### main 패키지

`main` 패키지는 **프로그램의 시작점**을 포함하는 특별한 패키지입니다.

```go
package main

func main() {
	// 프로그램 시작
}
```

**특징:**
- 반드시 `main()` 함수를 포함
- 실행 가능한 프로그램을 만들 때 사용
- 한 프로젝트에 하나만 존재

### 그 외 패키지

한 프로그램에는 `main` 패키지 외에 여러 패키지가 존재할 수 있습니다.

**표준 패키지 예시:**
- `fmt`: 표준 입출력
- `crypto`: 암호화 기능
- `net`: 네트워크 기능
- `math`: 수학 함수
- `time`: 시간 관련 기능

### 유용한 패키지 찾기

**공식 리소스:**
- [Go 표준 패키지](https://pkg.go.dev/std): 표준 라이브러리 문서
- [Awesome Go](https://github.com/avelino/awesome-go): 유용한 서드파티 패키지 모음

## 패키지 사용

### import 키워드

패키지를 사용하려면 `import` 키워드를 사용합니다.

```go
// 단일 패키지
import "fmt"

// 여러 패키지
import (
	"fmt"
	"os"
	"time"
)
```

### 외부 노출 규칙

패키지의 요소를 외부에 공개하려면 **첫 글자를 대문자**로 시작해야 합니다.

```go
package mypackage

// 외부 공개 (Public)
var PublicVar int
func PublicFunc() {}
type PublicStruct struct {}

// 외부 비공개 (Private)
var privateVar int
func privateFunc() {}
type privateStruct struct {}
```

**규칙:**
- **대문자 시작**: 외부 패키지에서 접근 가능
- **소문자 시작**: 같은 패키지 내부에서만 접근 가능

### 경로가 있는 패키지 사용

```go
package main

import (
	"fmt"
	"math/rand"
)

func main() {
	fmt.Println(rand.Int()) // 랜덤한 숫자 출력
}
```

**패키지 경로:**
- `math/rand`: math 폴더 아래의 rand 패키지
- 슬래시(`/`)로 경로 구분

### 패키지 별칭

패키지명이 겹치거나 긴 경우 별칭을 사용할 수 있습니다.

```go
import (
	"text/template"
	htemplate "html/template"  // 별칭 htemplate
)

func main() {
	// text/template 사용
	t := template.New("test")
	
	// html/template 사용
	ht := htemplate.New("test")
}
```

**별칭 활용:**
```go
import (
	f "fmt"  // fmt를 f로 줄임
	"math/rand"
)

func main() {
	f.Println("Hello")  // fmt.Println 대신 f.Println
}
```

### 사용하지 않는 패키지 포함

패키지를 직접 사용하지 않지만 **부가 효과(side effect)**를 얻고 싶을 때 사용합니다.

```go
import (
	"database/sql"
	_ "github.com/mattn/go-sqlite3"  // 초기화만 실행
)
```

**밑줄(_) 임포트:**
- 패키지의 `init()` 함수만 실행
- 패키지의 다른 기능은 사용하지 않음
- 주로 드라이버 등록에 사용

## Go 모듈

**Go 모듈(Module)**은 Go 패키지들을 모아놓은 프로젝트 단위입니다.

### go.mod 파일

모듈의 메타데이터를 담고 있는 파일입니다.

```go
module myproject

go 1.21

require (
	github.com/gin-gonic/gin v1.9.0
	github.com/stretchr/testify v1.8.2
)
```

**내용:**
- 모듈 이름
- Go 버전
- 필요한 외부 패키지와 버전

### 모듈 생성

```bash
go mod init [모듈명]
```

**예시:**
```bash
go mod init myproject
go mod init github.com/username/project
```

### 패키지 검색 순서

Go는 import된 패키지를 다음 순서로 찾습니다:

1. **표준 패키지**: Go 설치 경로
2. **외부 패키지**: `$GOPATH/pkg/mod` 또는 모듈 캐시
3. **현재 모듈**: 현재 프로젝트 내부 패키지

## 실습 1: 커스텀 패키지 만들기

실제로 패키지를 만들고 사용해보겠습니다.

### 1단계: 프로젝트 구조 생성

```bash
mkdir -p myproject/custompkg
cd myproject
go mod init myproject
```

### 2단계: 커스텀 패키지 작성

**파일: custompkg/custompkg.go**

```go
package custompkg

import "fmt"

// 외부 공개 함수
func PrintCustom() {
	fmt.Println("This is custom package!")
}

// 외부 공개 함수
func Add(a, b int) int {
	return a + b
}

// 비공개 함수
func privateFunc() {
	fmt.Println("This is private")
}
```

### 3단계: main 패키지에서 사용

**파일: main.go**

```go
package main

import (
	"fmt"
	"myproject/custompkg"
)

func main() {
	custompkg.PrintCustom()
	
	result := custompkg.Add(10, 20)
	fmt.Println("10 + 20 =", result)
	
	// custompkg.privateFunc()  // 에러! 비공개 함수
}
```

### 4단계: 실행

```bash
go run main.go
```

실행 결과:

```bash
This is custom package!
10 + 20 = 30
```

**프로젝트 구조:**
```
myproject/
├── go.mod
├── main.go
└── custompkg/
    └── custompkg.go
```

## 실습 2: 외부 패키지 사용

외부 패키지를 다운로드하고 사용해보겠습니다.

### 1단계: 프로젝트 생성

```bash
mkdir graphproject
cd graphproject
go mod init graphproject
```

### 2단계: 코드 작성

**파일: main.go**

```go
package main

import (
	"fmt"
	"github.com/guptarohit/asciigraph"
)

func main() {
	data := []float64{3, 4, 5, 6, 9, 7, 5, 8, 5, 10, 2, 7, 2, 5, 6}
	
	// ASCII 그래프 생성
	graph := asciigraph.Plot(data)
	
	fmt.Println("데이터 그래프:")
	fmt.Println(graph)
}
```

### 3단계: 패키지 다운로드

```bash
go mod tidy
```

`go mod tidy` 명령어는:
- 필요한 패키지를 자동으로 다운로드
- `go.mod`와 `go.sum` 파일 업데이트
- 사용하지 않는 패키지 제거

### 4단계: 실행

```bash
go run main.go
```

실행 결과:

```bash
데이터 그래프:
 10.00 ┤        ╭╮
  9.00 ┤   ╭╮   ││
  8.00 ┤   ││ ╭╮││
  7.00 ┤   │╰╮││││╭╮
  6.00 ┤  ╭╯ │││││││ ╭
  5.00 ┤ ╭╯  ╰╯╰╯│││╭╯
  4.00 ┤╭╯       ││││
  3.00 ┼╯        ││││
  2.00 ┤         ╰╯╰╯
```

## 패키지 외부 공개 상세

### 공개/비공개 예제

**파일: publicpkg/publicpkg.go**

```go
package publicpkg

import "fmt"

// 공개 상수
const PI = 3.1415

// 비공개 상수
const pi = 3.141516

// 공개 변수
var ScreenSize int = 1080

// 비공개 변수
var screenHeight int

// 공개 함수
func PublicFunc() {
	fmt.Println("This is a public function")
}

// 비공개 함수
func privateFunc() {
	fmt.Println("This is a private function")
}

// 공개 타입
type MyInt int
type MyStruct struct {
	Age  int    // 공개 필드
	name string // 비공개 필드
}

// 공개 메서드
func (m MyStruct) PublicMethod() {
	fmt.Println("This is a public method")
}

// 비공개 메서드
func (m MyStruct) privateMethod() {
	fmt.Println("This is a private method")
}

// 비공개 타입
type myPrivateStruct struct {
	Age int
}

// 비공개 타입의 메서드 (외부 접근 불가)
func (m myPrivateStruct) Method() {
	fmt.Println("Private struct method")
}
```

### 사용 예제

**파일: main.go**

```go
package main

import (
	"fmt"
	"myproject/publicpkg"
)

func main() {
	// 공개 상수 사용
	fmt.Println("PI:", publicpkg.PI)
	// fmt.Println(publicpkg.pi)  // 에러! 비공개
	
	// 공개 함수 호출
	publicpkg.PublicFunc()
	
	// 공개 타입 사용
	var myint publicpkg.MyInt = 10
	fmt.Println("myint:", myint)
	
	// 공개 구조체 생성
	var mystruct = publicpkg.MyStruct{
		Age: 18,
		// name: "John",  // 에러! 비공개 필드
	}
	fmt.Println("mystruct:", mystruct)
	
	// 공개 메서드 호출
	mystruct.PublicMethod()
	// mystruct.privateMethod()  // 에러! 비공개
}
```

실행 결과:

```bash
PI: 3.1415
This is a public function
myint: 10
mystruct: {18 }
This is a public method
```

## 패키지 초기화

패키지가 로드될 때 `init()` 함수가 자동으로 실행됩니다.

### init() 함수 특징

- 패키지당 여러 개 정의 가능
- 자동으로 실행 (호출 불가)
- `main()` 함수보다 먼저 실행
- 패키지 초기화 작업에 사용

### 초기화 순서 예제

**파일: initpkg/initpkg.go**

```go
package initpkg

import "fmt"

var (
	a = c + b  // 3단계: c(5) + b(4) = 9
	b = f()    // 2단계: f() 호출 → 4
	c = f()    // 1단계: f() 호출 → 5
	d = 3      // 0단계: 상수 초기화
)

func init() {
	d++
	fmt.Println("init() 함수 실행, d =", d)
}

func f() int {
	d++
	fmt.Printf("f() 호출, d = %d\n", d)
	return d
}

func PrintD() {
	fmt.Println("최종 d 값:", d)
}
```

**파일: main.go**

```go
package main

import (
	"fmt"
	"myproject/initpkg"
)

func main() {
	fmt.Println("main() 함수 시작")
	initpkg.PrintD()
}
```

실행 결과:

```bash
f() 호출, d = 4
f() 호출, d = 5
init() 함수 실행, d = 6
main() 함수 시작
최종 d 값: 6
```

**실행 순서:**
1. 전역 변수 초기화 (선언 순서가 아닌 의존성 순서)
2. `init()` 함수 실행
3. `main()` 함수 실행

### 여러 init() 함수

```go
package mypackage

import "fmt"

func init() {
	fmt.Println("첫 번째 init")
}

func init() {
	fmt.Println("두 번째 init")
}

func init() {
	fmt.Println("세 번째 init")
}
```

**실행 결과:**
```bash
첫 번째 init
두 번째 init
세 번째 init
```

순서대로 실행됩니다.

## 패키지 모범 사례

### 1. 패키지 이름 짓기

```go
// 좋은 예
package user
package http
package json

// 나쁜 예
package mypackage
package utils
package common
```

**규칙:**
- 짧고 명확하게
- 소문자만 사용
- 언더스코어 사용 안 함
- 의미 있는 이름

### 2. 패키지 구조

```
myproject/
├── go.mod
├── main.go
├── user/
│   ├── user.go
│   └── user_test.go
├── auth/
│   ├── auth.go
│   └── auth_test.go
└── database/
    ├── db.go
    └── db_test.go
```

**원칙:**
- 기능별로 패키지 분리
- 각 패키지는 명확한 책임
- 순환 의존성 피하기

### 3. 의존성 관리

```bash
# 모듈 생성
go mod init myproject

# 의존성 추가
go get github.com/gin-gonic/gin

# 의존성 정리
go mod tidy

# 의존성 업데이트
go get -u ./...

# 특정 버전 설치
go get github.com/gin-gonic/gin@v1.9.0
```

### 4. 벤더링

외부 의존성을 프로젝트에 포함시킬 수 있습니다:

```bash
go mod vendor
```

`vendor/` 폴더에 모든 의존성이 복사됩니다.

## go.mod 파일 상세

```go
module myproject

go 1.21

require (
	github.com/gin-gonic/gin v1.9.0
	github.com/stretchr/testify v1.8.2
)

require (
	// 간접 의존성 (자동 추가)
	github.com/gin-contrib/sse v0.1.0 // indirect
)

replace (
	// 패키지 교체
	github.com/old/package => github.com/new/package v1.0.0
)

exclude (
	// 특정 버전 제외
	github.com/bad/package v1.2.3
)
```

패키지 시스템을 잘 이해하면 큰 프로젝트도 깔끔하게 구조화할 수 있습니다!