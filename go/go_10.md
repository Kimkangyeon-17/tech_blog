# Go 언어 배열

배열은 같은 타입의 데이터들을 연속적으로 저장하는 자료구조입니다.

## 배열의 기본 개념

**용어 정리:**
- **요소(element)**: 배열을 이루는 각각의 값
- **인덱스(index)**: 각 요소의 위치를 나타내는 숫자 (0부터 시작)

### 기본 배열 예제

```go
package main

import "fmt"

func main() {
	var t [5]float64 = [5]float64{24.0, 25.9, 27.8, 26.9, 26.2}
	
	for i := 0; i < 5; i++ {
		fmt.Println(t[i])
	}
}
```

실행 결과:

```bash
24
25.9
27.8
26.9
26.2
```

**배열의 구조:**

| 인덱스 | 0 | 1 | 2 | 3 | 4 |
|--------|---|---|---|---|---|
| 값 | 24.0 | 25.9 | 27.8 | 26.9 | 26.2 |

## 배열 선언 방법

### 1. 기본 선언 (기본값으로 초기화)

```go
var nums [5]int
```

**결과:**

| nums[0] | nums[1] | nums[2] | nums[3] | nums[4] |
|---------|---------|---------|---------|---------|
| 0 | 0 | 0 | 0 | 0 |

별도의 초깃값을 지정하지 않으면 타입의 기본값으로 초기화됩니다.

### 2. 선언과 동시에 초기화

```go
var nums [5]int = [5]int{1, 2, 3, 4, 5}

// 타입 생략 (타입 추론)
nums := [5]int{1, 2, 3, 4, 5}
```

### 3. 배열 크기 자동 지정

```go
nums := [...]int{1, 2, 3, 4, 5}  // 컴파일러가 자동으로 크기를 5로 설정
```

`...`을 사용하면 초기값의 개수만큼 배열 크기가 자동으로 결정됩니다.

### 4. 특정 인덱스만 초기화

```go
var s = [5]int{1: 10, 3: 30}
```

**결과:**

| s[0] | s[1] | s[2] | s[3] | s[4] |
|------|------|------|------|------|
| 0 | 10 | 0 | 30 | 0 |

- 인덱스 1의 값은 10
- 인덱스 3의 값은 30
- 나머지는 기본값 0

**활용 예시:**

```go
// 큰 배열에서 특정 위치만 초기화
config := [100]int{0: 1, 50: 999, 99: -1}
```

## 배열 선언 시 크기는 항상 상수

배열의 크기는 **컴파일 시점에 결정**되어야 하므로 반드시 상수를 사용해야 합니다.

```go
package main

const Y int = 3

func main() {
	x := 5
	// a := [x]int{1, 2, 3, 4, 5}  // 에러! 변수는 사용 불가

	b := [Y]int{1, 2, 3}  // OK! 상수는 사용 가능

	var c [10]int  // OK! 리터럴 상수 사용
	
	d := [...]int{1, 2, 3}  // OK! 컴파일러가 크기 결정
}
```

**컴파일 에러:**

```bash
./prog.go:7:7: non-constant array bound x
```

**이유:**
- Go의 배열 크기는 타입의 일부입니다
- `[5]int`와 `[10]int`는 서로 다른 타입입니다
- 컴파일 시점에 타입이 결정되어야 하므로 크기도 컴파일 시점에 정해져야 합니다

## 배열 요소 읽고 쓰기

### 요소 접근 및 수정

```go
package main

import "fmt"

func main() {
	nums := [...]int{10, 20, 30, 40, 50}

	// 읽기
	fmt.Println(nums[0])  // 10
	fmt.Println(nums[2])  // 30

	// 쓰기
	nums[2] = 300

	// len() 함수로 배열 길이 확인
	for i := 0; i < len(nums); i++ {
		fmt.Println(nums[i])
	}
}
```

실행 결과:

```bash
10
30
10
20
300
40
50
```

**배열 인덱스 규칙:**
- 인덱스는 **0부터 시작**합니다
- 최대 인덱스는 **길이 - 1**입니다
- 범위를 벗어나면 **런타임 에러** 발생 (panic)

```go
nums := [3]int{1, 2, 3}
fmt.Println(nums[3])  // 에러! index out of range
```

## range를 이용한 배열 순회

`range` 키워드를 사용하면 배열을 편리하게 순회할 수 있습니다.

```go
package main

import "fmt"

func main() {
	var t [5]float64 = [5]float64{24.0, 25.9, 27.8, 26.9, 26.2}

	for i, v := range t {
		fmt.Printf("t[%d] = %.1f\n", i, v)
	}
}
```

실행 결과:

```bash
t[0] = 24.0
t[1] = 25.9
t[2] = 27.8
t[3] = 26.9
t[4] = 26.2
```

**range의 반환값:**
- 첫 번째: 인덱스
- 두 번째: 해당 인덱스의 값 (복사본)

### range 활용 패턴

```go
// 인덱스만 필요한 경우
for i := range t {
	fmt.Println(i)
}

// 값만 필요한 경우
for _, v := range t {
	fmt.Println(v)
}

// 단순히 횟수만 반복하는 경우
for range t {
	fmt.Println("반복")
}
```

## 배열은 연속된 메모리

배열을 선언하면 컴퓨터는 **연속된 메모리 공간**을 확보합니다.

### 메모리 주소 계산

```
요소 위치 = 배열 시작 주소 + (인덱스 × 타입 크기)
```

**예시: [5]int 배열**

```go
nums := [5]int{10, 20, 30, 40, 50}
```

| 인덱스 | 값 | 메모리 주소 (가정) |
|--------|----|--------------------|
| 0 | 10 | 0x1000 |
| 1 | 20 | 0x1008 (0x1000 + 8) |
| 2 | 30 | 0x1010 (0x1000 + 16) |
| 3 | 40 | 0x1018 (0x1000 + 24) |
| 4 | 50 | 0x1020 (0x1000 + 32) |

*int는 64비트 시스템에서 8바이트*

**연속 메모리의 장점:**
- 인덱스로 요소에 빠르게 접근 가능 (O(1))
- CPU 캐시 효율성이 높음
- 메모리 관리가 간단함

## 배열 복사

Go에서 배열을 대입하면 **전체 배열이 복사**됩니다.

```go
package main

import "fmt"

func main() {
	a := [5]int{1, 2, 3, 4, 5}
	b := [5]int{500, 400, 300, 200, 100}

	fmt.Println("=== 복사 전 ===")
	fmt.Println("a:", a)
	fmt.Println("b:", b)

	b = a  // 배열 전체가 복사됨

	fmt.Println("\n=== 복사 후 ===")
	fmt.Println("b:", b)

	// a를 수정해도 b는 영향 없음
	a[0] = 999
	fmt.Println("\n=== a[0] 수정 후 ===")
	fmt.Println("a:", a)
	fmt.Println("b:", b)  // b는 변경되지 않음
}
```

실행 결과:

```bash
=== 복사 전 ===
a: [1 2 3 4 5]
b: [500 400 300 200 100]

=== 복사 후 ===
b: [1 2 3 4 5]

=== a[0] 수정 후 ===
a: [999 2 3 4 5]
b: [1 2 3 4 5]
```

**중요한 특징:**
- 배열 대입은 **값 복사(value copy)**입니다
- 원본과 복사본은 **독립적**입니다
- 큰 배열을 복사하면 성능에 영향을 줄 수 있습니다

### 배열 비교

같은 타입의 배열끼리는 `==`와 `!=`로 비교 가능합니다:

```go
a := [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [3]int{1, 2, 4}

fmt.Println(a == b)  // true
fmt.Println(a == c)  // false
```

## 다차원 배열

배열의 요소로 배열을 가질 수 있습니다.

### 2차원 배열

```go
package main

import "fmt"

func main() {
	a := [2][5]int{
		{1, 2, 3, 4, 5},
		{6, 7, 8, 9, 10},
	}

	for _, arr := range a {
		for _, v := range arr {
			fmt.Printf("%2d ", v)
		}
		fmt.Println()
	}
}
```

실행 결과:

```bash
 1  2  3  4  5 
 6  7  8  9 10 
```

**2차원 배열의 구조:**

```
[2][5]int는 [5]int 배열 2개를 가진 배열

행(row) 0: [1, 2, 3, 4, 5]
행(row) 1: [6, 7, 8, 9, 10]
```

### 2차원 배열 접근

```go
a := [2][3]int{
	{1, 2, 3},
	{4, 5, 6},
}

fmt.Println(a[0][1])  // 2 (첫 번째 행, 두 번째 열)
fmt.Println(a[1][2])  // 6 (두 번째 행, 세 번째 열)

a[1][0] = 999
fmt.Println(a)  // [[1 2 3] [999 5 6]]
```

### 3차원 배열

```go
// 3차원 공간의 좌표
cube := [2][2][2]int{
	{
		{1, 2},
		{3, 4},
	},
	{
		{5, 6},
		{7, 8},
	},
}

fmt.Println(cube[0][1][1])  // 4
```

## 배열의 크기

배열의 전체 크기는 다음과 같이 계산됩니다:

```
배열 크기 = 타입 크기 × 요소 개수
```

### 크기 계산 예시

```go
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	var a [5]int        // int는 8바이트 (64비트 시스템)
	var b [10]float64   // float64는 8바이트
	var c [2][5]int     // [5]int가 2개

	fmt.Printf("[5]int 크기: %d바이트\n", unsafe.Sizeof(a))
	fmt.Printf("[10]float64 크기: %d바이트\n", unsafe.Sizeof(b))
	fmt.Printf("[2][5]int 크기: %d바이트\n", unsafe.Sizeof(c))
}
```

실행 결과:

```bash
[5]int 크기: 40바이트
[10]float64 크기: 80바이트
[2][5]int 크기: 80바이트
```

**계산 과정:**
- `[5]int`: 8 × 5 = 40바이트
- `[10]float64`: 8 × 10 = 80바이트
- `[2][5]int`: [5]int의 크기가 40바이트이므로, 40 × 2 = 80바이트

## 배열의 한계와 대안

### 배열의 한계

```go
func printArray(arr [5]int) {  // [5]int만 받을 수 있음
	for _, v := range arr {
		fmt.Print(v, " ")
	}
}

a := [5]int{1, 2, 3, 4, 5}
b := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

printArray(a)   // OK
// printArray(b)   // 에러! [10]int는 [5]int와 다른 타입
```

**배열의 문제점:**
1. **크기가 고정**: 런타임에 크기 변경 불가
2. **크기가 타입의 일부**: [5]int와 [10]int는 완전히 다른 타입
3. **함수 전달 시 복사**: 큰 배열은 성능 문제
4. **유연성 부족**: 동적 데이터 처리에 부적합

### 해결책: 슬라이스

대부분의 경우 배열 대신 **슬라이스(Slice)**를 사용합니다:

```go
func printSlice(arr []int) {  // 모든 크기의 int 슬라이스 가능
	for _, v := range arr {
		fmt.Print(v, " ")
	}
}

a := []int{1, 2, 3, 4, 5}
b := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

printSlice(a)  // OK
printSlice(b)  // OK
```

**슬라이스의 장점:**
- 크기가 유동적
- 함수에 참조로 전달 (복사 부담 없음)
- 더 유연하고 실용적

## 정리
배열은 Go의 기본 자료구조이지만, 크기 제약 때문에 실무에서는 슬라이스를 더 많이 사용합니다!