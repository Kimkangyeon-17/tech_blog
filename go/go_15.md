# Go 언어 슬라이스

슬라이스는 Go에서 가장 많이 사용하는 자료구조입니다. 배열보다 유연하고 강력합니다.

## 슬라이스란?

**슬라이스(Slice)**는 Go 언어에서 제공하는 **동적 배열**입니다.

**배열 vs 슬라이스:**

| 특징 | 배열 | 슬라이스 |
|------|------|---------|
| 크기 | 고정 | 가변 |
| 타입 | `[5]int` | `[]int` |
| 유연성 | 낮음 | 높음 |
| 사용 빈도 | 드묾 | 매우 많음 |

## 슬라이스 선언

### 배열 선언 (비교)

```go
var array [10]int  // 크기 10으로 고정
```

### 슬라이스 선언

```go
var slice []int  // 크기 지정 없음
```

**주의:** 초기화하지 않으면 길이 0인 슬라이스가 생성됩니다.

### 초기화하지 않은 슬라이스 사용 시 에러

```go
package main

import "fmt"

func main() {
	var slice []int

	if len(slice) == 0 {
		fmt.Println("slice is empty", slice)
	}

	// slice[1] = 10  // 패닉 발생!
	fmt.Println(slice)
}
```

실행 결과:

```bash
slice is empty []
[]
```

**범위 초과 접근 시:**

```go
slice[1] = 10  // 패닉!
```

```bash
panic: runtime error: index out of range [1] with length 0
```

**중요:** 길이가 0이므로 인덱스 1에 접근할 수 없습니다.

## 슬라이스 초기화 방법

### 1. {} 리터럴 사용

```go
var slice1 = []int{1, 2, 3}
var slice2 = []int{1, 5: 2, 10: 3}  // 인덱스 지정
```

**slice2 결과:**
```
[1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 3]
```

### 2. make() 함수 사용 (권장)

```go
var slice = make([]int, 3)     // 길이 3
var slice2 = make([]int, 3, 5) // 길이 3, 용량 5
```

**make() 함수 문법:**
```go
make([]타입, 길이, 용량)
```

- **길이(len)**: 현재 요소 개수
- **용량(cap)**: 할당된 공간 크기

### 3. nil 슬라이스와 빈 슬라이스

```go
var nilSlice []int              // nil 슬라이스
emptySlice := []int{}           // 빈 슬라이스
makeSlice := make([]int, 0)     // 빈 슬라이스

fmt.Println(nilSlice == nil)    // true
fmt.Println(emptySlice == nil)  // false
fmt.Println(makeSlice == nil)   // false
```

## 슬라이스 기본 사용

### 요소 접근

배열과 동일하게 인덱스로 접근합니다.

```go
var slice = make([]int, 3)
slice[0] = 1
slice[1] = 5
slice[2] = 9

fmt.Println(slice[1])  // 5
```

### 슬라이스 순회

```go
package main

import "fmt"

func main() {
	var slice = []int{1, 2, 3}

	// 인덱스로 순회
	for i := 0; i < len(slice); i++ {
		slice[i] += 10
	}
	fmt.Println(slice)  // [11 12 13]

	// range로 순회 (권장)
	for i, v := range slice {
		slice[i] = v * 2
	}
	fmt.Println(slice)  // [22 24 26]
}
```

## append()로 요소 추가

`append()` 함수는 슬라이스에 요소를 추가합니다.

### 기본 사용

```go
package main

import "fmt"

func main() {
	var slice = []int{1, 2, 3}

	slice2 := append(slice, 4)           // 요소 1개 추가
	slice3 := append(slice2, 5, 6, 7)    // 요소 여러 개 추가

	fmt.Println(slice)   // [1 2 3]
	fmt.Println(slice2)  // [1 2 3 4]
	fmt.Println(slice3)  // [1 2 3 4 5 6 7]
}
```

### 슬라이스 합치기

```go
slice1 := []int{1, 2, 3}
slice2 := []int{4, 5, 6}

// ... 연산자로 슬라이스 펼치기
slice3 := append(slice1, slice2...)
fmt.Println(slice3)  // [1 2 3 4 5 6]
```

### append() 주의사항

```go
slice := []int{1, 2, 3}
newSlice := append(slice, 4)

// slice와 newSlice가 같은 배열을 가리킬 수도 있음!
slice[0] = 100
fmt.Println(newSlice)  // [100 2 3 4] 일 수도 있음
```

**안전하게 사용하려면 복사 후 추가하세요.**

## 슬라이스 동작 원리

### SliceHeader 구조체

슬라이스의 내부 구조는 다음과 같습니다:

```go
type SliceHeader struct {
	Data uintptr  // 실제 배열을 가리키는 포인터
	Len  int      // 요소 개수
	Cap  int      // 할당된 배열의 용량
}
```

**구조 설명:**
- **Data**: 실제 데이터 배열의 주소
- **Len**: 현재 사용 중인 요소 개수
- **Cap**: 재할당 없이 추가 가능한 최대 개수

### 슬라이스 vs 배열 동작 차이

```go
package main

import "fmt"

func changeArray(array2 [5]int) {
	array2[2] = 200
}

func changeSlice(slice2 []int) {
	slice2[2] = 200
}

func main() {
	array := [5]int{1, 2, 3, 4, 5}
	slice := []int{1, 2, 3, 4, 5}

	changeArray(array)
	changeSlice(slice)

	fmt.Println("array:", array)  // [1 2 3 4 5]
	fmt.Println("slice:", slice)  // [1 2 200 4 5]
}
```

실행 결과:

```bash
array: [1 2 3 4 5]
slice: [1 2 200 4 5]
```

**왜 다를까요?**

### 동작 차이 원인

**배열의 경우:**
```
array 전체가 복사됨
→ array와 array2는 완전히 다른 메모리
→ array2 변경해도 array는 불변
```

**슬라이스의 경우:**
```
SliceHeader 구조체만 복사됨
→ Data 포인터가 복사됨 (같은 배열을 가리킴)
→ slice2 변경 = slice도 변경
```

**메모리 구조:**

```
[배열]
array: [1][2][3][4][5]  (20바이트 전체 복사)

[슬라이스]
slice:  Data → [1][2][3][4][5]
              ↑
slice2: Data ┘  (포인터만 복사, 같은 배열 공유)
```

## 슬라이싱 (Slicing)

슬라이싱은 배열이나 슬라이스의 일부를 추출하는 기능입니다.

### 기본 문법

```go
slice := array[startIdx:endIdx]
```

- **startIdx**: 시작 인덱스 (포함)
- **endIdx**: 끝 인덱스 (미포함)

### 슬라이싱 예제

```go
package main

import "fmt"

func main() {
	array := [5]int{1, 2, 3, 4, 5}
	
	slice := array[1:3]  // 인덱스 1, 2 (3은 미포함)
	
	fmt.Println("array:", array)
	fmt.Println("slice:", slice, "len:", len(slice), "cap:", cap(slice))

	array[1] = 100

	fmt.Println("\nAfter change array[1]")
	fmt.Println("array:", array)
	fmt.Println("slice:", slice)  // 같이 변경됨!

	slice = append(slice, 500)

	fmt.Println("\nAfter append 500")
	fmt.Println("array:", array)  // 배열도 변경됨!
	fmt.Println("slice:", slice, "len:", len(slice), "cap:", cap(slice))
}
```

실행 결과:

```bash
array: [1 2 3 4 5]
slice: [2 3] len: 2 cap: 4

After change array[1]
array: [1 100 3 4 5]
slice: [100 3]

After append 500
array: [1 100 3 500 5]
slice: [100 3 500] len: 3 cap: 4
```

**핵심:** 슬라이싱한 slice는 원본 배열을 공유합니다!

### 슬라이싱 단축 표현

```go
slice := []int{1, 2, 3, 4, 5}

slice[:]    // [1 2 3 4 5] (전체)
slice[2:]   // [3 4 5] (인덱스 2부터 끝까지)
slice[:3]   // [1 2 3] (처음부터 인덱스 2까지)
slice[1:4]  // [2 3 4] (인덱스 1~3)
```

### 3개 인덱스로 cap 조절

```go
slice[시작:끝:최대]
```

```go
package main

import "fmt"

func main() {
	slice1 := []int{1, 2, 3, 4, 5}
	
	slice2 := slice1[1:3]     // cap은 4 (5-1)
	slice3 := slice1[1:3:4]   // cap은 3 (4-1)

	fmt.Println("slice2:", slice2, "cap:", cap(slice2))
	fmt.Println("slice3:", slice3, "cap:", cap(slice3))
}
```

실행 결과:

```bash
slice2: [2 3] cap: 4
slice3: [2 3] cap: 3
```

**용도:** 용량을 제한하여 원본 배열 보호

## 슬라이스 복사

### 수동 복사

```go
package main

import "fmt"

func main() {
	slice1 := []int{1, 2, 3, 4, 5}
	slice2 := make([]int, len(slice1))

	for i, v := range slice1 {
		slice2[i] = v
	}

	slice1[1] = 100

	fmt.Println(slice1)  // [1 100 3 4 5]
	fmt.Println(slice2)  // [1 2 3 4 5]
}
```

### copy() 함수 사용 (권장)

```go
package main

import "fmt"

func main() {
	slice1 := []int{1, 2, 3, 4, 5}
	slice2 := make([]int, 3)
	slice3 := make([]int, 10)

	cnt1 := copy(slice2, slice1)  // 작은 쪽만큼만 복사
	cnt2 := copy(slice3, slice1)  // 전체 복사

	fmt.Println(cnt1, slice2)  // 3 [1 2 3]
	fmt.Println(cnt2, slice3)  // 5 [1 2 3 4 5 0 0 0 0 0]
}
```

**copy() 함수 특징:**
- 목적지 크기만큼만 복사
- 복사된 요소 개수 반환
- 안전하고 효율적

## 슬라이스 요소 삭제

### 중간 요소 삭제

```go
package main

import "fmt"

func main() {
	slice := []int{1, 2, 3, 4, 5, 6}
	idx := 2  // 인덱스 2 삭제

	// 방법 1: 수동 이동
	for i := idx + 1; i < len(slice); i++ {
		slice[i-1] = slice[i]
	}
	slice = slice[:len(slice)-1]

	fmt.Println(slice)  // [1 2 4 5 6]
}
```

### append()로 삭제 (더 간단)

```go
package main

import "fmt"

func main() {
	slice := []int{1, 2, 3, 4, 5, 6}
	idx := 2

	// idx를 제외하고 앞뒤 합치기
	slice = append(slice[:idx], slice[idx+1:]...)

	fmt.Println(slice)  // [1 2 4 5 6]
}
```

### 마지막 요소 삭제

```go
slice := []int{1, 2, 3, 4, 5}
slice = slice[:len(slice)-1]
fmt.Println(slice)  // [1 2 3 4]
```

### 첫 번째 요소 삭제

```go
slice := []int{1, 2, 3, 4, 5}
slice = slice[1:]
fmt.Println(slice)  // [2 3 4 5]
```

## 슬라이스 요소 삽입

### 중간에 요소 삽입

```go
package main

import "fmt"

func main() {
	slice := []int{1, 2, 3, 4, 5, 6}
	idx := 2
	value := 100

	// 방법 1: 수동 이동
	slice = append(slice, 0)  // 공간 확보
	for i := len(slice) - 2; i >= idx; i-- {
		slice[i+1] = slice[i]
	}
	slice[idx] = value

	fmt.Println(slice)  // [1 2 100 3 4 5 6]
}
```

### append()로 삽입 (더 간단)

```go
package main

import "fmt"

func main() {
	slice := []int{1, 2, 3, 4, 5, 6}
	idx := 2
	value := 100

	// idx 위치에 삽입
	slice = append(slice[:idx], append([]int{value}, slice[idx:]...)...)

	fmt.Println(slice)  // [1 2 100 3 4 5 6]
}
```

## 슬라이스 정렬

### 정수 슬라이스 정렬

```go
package main

import (
	"fmt"
	"sort"
)

func main() {
	s := []int{5, 2, 6, 3, 1, 4}
	
	sort.Ints(s)         // 오름차순
	fmt.Println(s)       // [1 2 3 4 5 6]
	
	sort.Sort(sort.Reverse(sort.IntSlice(s)))  // 내림차순
	fmt.Println(s)       // [6 5 4 3 2 1]
}
```

### 문자열 슬라이스 정렬

```go
package main

import (
	"fmt"
	"sort"
)

func main() {
	s := []string{"banana", "apple", "cherry"}
	
	sort.Strings(s)
	fmt.Println(s)  // [apple banana cherry]
}
```

### 구조체 슬라이스 정렬

`sort.Interface`를 구현해야 합니다.

```go
package main

import (
	"fmt"
	"sort"
)

type Student struct {
	Name string
	Age  int
}

// sort.Interface 구현
type Students []Student

func (s Students) Len() int           { return len(s) }
func (s Students) Less(i, j int) bool { return s[i].Age < s[j].Age }
func (s Students) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }

func main() {
	s := []Student{
		{"화랑", 31}, {"백두산", 52}, {"류", 42},
		{"켄", 38}, {"송하나", 18},
	}

	sort.Sort(Students(s))
	fmt.Println(s)
}
```

실행 결과:

```bash
[{송하나 18} {화랑 31} {켄 38} {류 42} {백두산 52}]
```

### sort.Slice() 사용 (Go 1.8+, 더 간단)

```go
package main

import (
	"fmt"
	"sort"
)

type Student struct {
	Name string
	Age  int
}

func main() {
	s := []Student{
		{"화랑", 31}, {"백두산", 52}, {"류", 42},
		{"켄", 38}, {"송하나", 18},
	}

	// 나이로 정렬
	sort.Slice(s, func(i, j int) bool {
		return s[i].Age < s[j].Age
	})
	fmt.Println("나이순:", s)

	// 이름으로 정렬
	sort.Slice(s, func(i, j int) bool {
		return s[i].Name < s[j].Name
	})
	fmt.Println("이름순:", s)
}
```

## 슬라이스 활용 팁

### 1. 용량 미리 할당

```go
// 비효율적
var slice []int
for i := 0; i < 1000; i++ {
	slice = append(slice, i)  // 여러 번 재할당
}

// 효율적
slice := make([]int, 0, 1000)
for i := 0; i < 1000; i++ {
	slice = append(slice, i)  // 재할당 없음
}
```

### 2. 슬라이스 초기화

```go
slice := make([]int, 0, 10)  // len=0, cap=10
// vs
slice := make([]int, 10)     // len=10, cap=10 (0으로 초기화됨)
```

### 3. 메모리 누수 방지

```go
// 큰 슬라이스에서 작은 부분만 필요할 때
bigSlice := make([]int, 1000000)
// ...

// 나쁜 예: bigSlice 전체를 참조
smallSlice := bigSlice[:10]

// 좋은 예: 복사해서 사용
smallSlice := make([]int, 10)
copy(smallSlice, bigSlice[:10])
```

## 슬라이스 vs 배열 언제 사용?

### 배열 사용 시

- 크기가 절대 변하지 않을 때
- 작은 고정 크기 데이터 (예: RGB 색상 [3]int)
- 스택 메모리에 할당하고 싶을 때

### 슬라이스 사용 시 (대부분)

- 크기가 가변적일 때
- 함수 인자로 전달할 때
- 동적 데이터 처리
- 일반적인 모든 경우

슬라이스는 Go에서 가장 많이 사용하는 자료구조입니다. 동작 원리를 이해하면 효율적이고 안전한 코드를 작성할 수 있습니다!