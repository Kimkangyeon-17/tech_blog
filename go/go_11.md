# Go 언어 구조체

구조체(struct)는 **여러 필드를 묶어서 하나의 타입**을 만드는 자료구조입니다.

**배열 vs 구조체:**
- **배열**: 같은 타입의 값들을 묶음
- **구조체**: 다른 타입의 값들을 묶음

## 구조체 선언 및 기본 사용

### 기본 문법

```go
type 타입명 struct {
    필드명 타입
    ...
    필드명 타입
}
```

**규칙:**
- `type` 키워드로 새로운 타입을 정의
- `struct` 키워드로 구조체임을 명시
- 필드명은 대소문자로 시작 가능 (대문자: 외부 패키지 접근 가능)

### 구조체 정의 예시

```go
type Student struct {
    Name  string
    Class int
    No    int
    Score float64
}
```

### 구조체 사용 예제

```go
package main

import "fmt"

type House struct {
	Address string
	Size    int
	Price   float64
	Type    string
}

func main() {
	var house House
	house.Address = "서울시 동작구"
	house.Size = 28
	house.Price = 9.8
	house.Type = "아파트"

	fmt.Println("주소:", house.Address)
	fmt.Printf("크기: %d평\n", house.Size)
	fmt.Printf("가격: %.2f억원\n", house.Price)
	fmt.Println("타입:", house.Type)
}
```

실행 결과:

```bash
주소: 서울시 동작구
크기: 28평
가격: 9.80억원
타입: 아파트
```

**필드 접근:**
- 점(`.`) 연산자로 필드에 접근
- `구조체변수.필드명` 형태

## 구조체 변수 초기화

구조체 변수를 선언하고 초기화하는 다양한 방법이 있습니다.

### 1. 초기값 생략 (기본값으로 초기화)

```go
var house House
// 모든 필드가 타입의 기본값으로 초기화
// Address: ""
// Size: 0
// Price: 0.0
// Type: ""
```

### 2. 모든 필드 초기화 (순서대로)

```go
var house House = House{"서울시 동작구", 28, 9.80, "아파트"}

// 짧은 형태
house := House{"서울시 동작구", 28, 9.80, "아파트"}
```

**주의:** 필드 순서를 정확히 지켜야 합니다.

### 3. 필드명 지정 초기화 (권장)

```go
var house House = House{
    Size: 28,
    Type: "아파트",
}
// Address: "" (기본값)
// Price: 0.0 (기본값)

// 짧은 형태
house := House{
    Address: "서울시 동작구",
    Size:    28,
    Price:   9.80,
    Type:    "아파트",
}
```

**장점:**
- 필드 순서를 신경 쓰지 않아도 됨
- 일부 필드만 초기화 가능
- 코드의 의도가 명확함
- 필드가 추가되어도 기존 코드가 안전함

### 4. new() 함수 사용

```go
house := new(House)  // 포인터 반환
house.Address = "서울시 동작구"

fmt.Println(house.Address)  // 포인터도 점 연산자 사용 가능
```

## 구조체를 포함하는 구조체

구조체는 다른 구조체를 필드로 포함할 수 있습니다.

### 방법 1: 필드명을 명시하는 방식

```go
type User struct {
    Name string
    ID   string
    Age  int
}

type VIPUser struct {
    UserInfo User  // User 타입의 필드
    VIPLevel int
    Price    int
}
```

**사용 예제:**

```go
package main

import "fmt"

type User struct {
	Name string
	ID   string
	Age  int
}

type VIPUser struct {
	UserInfo User
	VIPLevel int
	Price    int
}

func main() {
	user := User{"송하나", "hana", 23}
	vip := VIPUser{
		UserInfo: User{"화랑", "hwarang", 40},
		VIPLevel: 3,
		Price:    250,
	}

	fmt.Printf("유저: %s ID: %s 나이: %d\n", user.Name, user.ID, user.Age)
	fmt.Printf("VIP 유저: %s ID: %s 나이: %d VIP 레벨: %d VIP 가격: %d만 원\n",
		vip.UserInfo.Name,    // UserInfo를 통해 접근
		vip.UserInfo.ID,
		vip.UserInfo.Age,
		vip.VIPLevel,
		vip.Price,
	)
}
```

실행 결과:

```bash
유저: 송하나 ID: hana 나이: 23
VIP 유저: 화랑 ID: hwarang 나이: 40 VIP 레벨: 3 VIP 가격: 250만 원
```

### 방법 2: 임베디드 필드 방식 (추천)

필드명 없이 타입만 선언하면 **임베디드 필드(embedded field)**가 됩니다.

```go
type VIPUser struct {
    User      // 타입만 명시 (필드명 없음)
    VIPLevel int
    Price    int
}
```

**사용 예제:**

```go
package main

import "fmt"

type User struct {
	Name string
	ID   string
	Age  int
}

type VIPUser struct {
	User     // 임베디드 필드
	VIPLevel int
	Price    int
}

func main() {
	user := User{"송하나", "hana", 23}
	vip := VIPUser{
		User:     User{"화랑", "hwarang", 40},
		VIPLevel: 3,
		Price:    250,
	}

	fmt.Printf("유저: %s ID: %s 나이: %d\n", user.Name, user.ID, user.Age)
	fmt.Printf("VIP 유저: %s ID: %s 나이: %d VIP 레벨: %d VIP 가격: %d만 원\n",
		vip.Name,      // 직접 접근 가능!
		vip.ID,        // 직접 접근 가능!
		vip.Age,       // 직접 접근 가능!
		vip.VIPLevel,
		vip.Price,
	)
}
```

실행 결과:

```bash
유저: 송하나 ID: hana 나이: 23
VIP 유저: 화랑 ID: hwarang 나이: 40 VIP 레벨: 3 VIP 가격: 250만 원
```

**임베디드 필드의 장점:**
- User의 필드들을 VIPUser에서 직접 접근 가능
- 코드가 더 간결해짐
- 일종의 상속처럼 동작 (Go에는 상속이 없지만 이를 대체)

### 필드명 충돌 해결

임베디드 필드와 외부 구조체에 같은 이름의 필드가 있으면 어떻게 될까요?

```go
package main

import "fmt"

type User struct {
	Name  string
	ID    string
	Age   int
	Level int  // User에 Level 필드
}

type VIPUser struct {
	User
	Price int
	Level int  // VIPUser에도 Level 필드
}

func main() {
	user := User{"송하나", "hana", 23, 10}
	vip := VIPUser{
		User:  User{"화랑", "hwarang", 40, 10},
		Price: 250,
		Level: 3,
	}

	fmt.Printf("유저: %s ID: %s 나이: %d 레벨: %d\n", 
		user.Name, user.ID, user.Age, user.Level)
	fmt.Printf("VIP 유저: %s ID: %s 나이: %d VIP 레벨: %d 유저 레벨: %d\n",
		vip.Name,
		vip.ID,
		vip.Age,
		vip.Level,       // VIPUser의 Level (가까운 것 우선)
		vip.User.Level,  // User의 Level (명시적 접근)
	)
}
```

실행 결과:

```bash
유저: 송하나 ID: hana 나이: 23 레벨: 10
VIP 유저: 화랑 ID: hwarang 나이: 40 VIP 레벨: 3 유저 레벨: 10
```

**충돌 해결 규칙:**
1. **가까운 필드 우선**: `vip.Level`은 VIPUser의 Level
2. **명시적 접근**: `vip.User.Level`로 User의 Level 접근 가능

### 두 방식 비교

| 특징 | 필드명 명시 | 임베디드 필드 |
|------|------------|--------------|
| 선언 | `UserInfo User` | `User` |
| 접근 | `vip.UserInfo.Name` | `vip.Name` |
| 간결성 | 보통 | 높음 |
| 명확성 | 높음 | 보통 |
| 사용 시기 | 관계가 명확할 때 | 상속처럼 쓸 때 |

## 구조체 값 복사

Go의 구조체는 배열처럼 **값 타입(value type)**입니다.

```go
package main

import "fmt"

type Student struct {
	Age   int
	No    int
	Score float64
}

func PrintStudent(s Student) {
	fmt.Printf("나이: %d 번호: %d 점수: %.2f\n", s.Age, s.No, s.Score)
}

func main() {
	var student = Student{15, 23, 88.2}
	student2 := student  // 전체 복사

	PrintStudent(student2)
	
	// 원본 수정
	student.Age = 20
	fmt.Printf("student 나이: %d\n", student.Age)
	fmt.Printf("student2 나이: %d\n", student2.Age)  // 영향 없음
}
```

실행 결과:

```bash
나이: 15 번호: 23 점수: 88.20
student 나이: 20
student2 나이: 15
```

**중요한 특징:**
- 구조체 대입은 **전체 복사**
- 함수에 전달할 때도 복사됨
- 큰 구조체는 복사 비용이 클 수 있음
- 참조가 필요하면 **포인터** 사용

## 구조체 크기와 메모리 패딩

구조체 변수가 선언되면 메모리 공간이 할당됩니다.

### 기본 크기 계산

```go
package main

import (
	"fmt"
	"unsafe"
)

type User struct {
	Age   int32    // 4바이트
	Score float64  // 8바이트
}

func main() {
	user := User{23, 77.2}
	fmt.Println(unsafe.Sizeof(user))  // 16
}
```

실행 결과:

```bash
16
```

**예상:** 4 + 8 = 12바이트
**실제:** 16바이트

**이유:** 메모리 정렬(Memory Alignment)과 패딩(Padding)

### 메모리 패딩이란?

CPU는 데이터를 효율적으로 읽기 위해 **특정 주소 경계**에 맞춰 데이터를 배치합니다.

**메모리 패딩 예시:**

```go
package main

import (
	"fmt"
	"unsafe"
)

type User struct {
	A int8  // 1바이트
	B int   // 8바이트 (64비트 시스템)
	C int8  // 1바이트
	D int   // 8바이트
	E int8  // 1바이트
}

func main() {
	user := User{1, 2, 3, 4, 5}
	fmt.Println(unsafe.Sizeof(user))
}
```

실행 결과:

```bash
40
```

**메모리 배치:**

```
A: 1바이트
패딩: 7바이트
B: 8바이트
C: 1바이트
패딩: 7바이트
D: 8바이트
E: 1바이트
패딩: 7바이트
---
총: 40바이트
```

### 메모리 패딩 최적화

필드 순서를 조정하면 메모리를 절약할 수 있습니다!

```go
package main

import (
	"fmt"
	"unsafe"
)

type User struct {
	A int8  // 1바이트
	C int8  // 1바이트
	E int8  // 1바이트
	// 패딩: 5바이트
	B int   // 8바이트
	D int   // 8바이트
}

func main() {
	user := User{1, 3, 5, 2, 4}
	fmt.Println(unsafe.Sizeof(user))
}
```

실행 결과:

```bash
24
```

**최적화 결과:** 40바이트 → 24바이트 (40% 절약!)

**최적화 팁:**
1. 큰 타입부터 배치 (int64, float64)
2. 중간 타입 (int32, float32)
3. 작은 타입 (int8, int16, bool)
4. 같은 크기끼리 묶어서 배치

### 최적화 전후 비교

```go
// 비효율적 (40바이트)
type Bad struct {
	A int8   // 1
	B int64  // 패딩 7 + 8
	C int8   // 1
	D int64  // 패딩 7 + 8
	E int8   // 1 + 패딩 7
}

// 효율적 (24바이트)
type Good struct {
	B int64  // 8
	D int64  // 8
	A int8   // 1
	C int8   // 1
	E int8   // 1 + 패딩 5
}
```

## 구조체 메서드

구조체에 메서드를 추가할 수 있습니다 (다음 포스트에서 자세히 다룸):

```go
type Rectangle struct {
	Width  int
	Height int
}

// 메서드 정의
func (r Rectangle) Area() int {
	return r.Width * r.Height
}

func main() {
	rect := Rectangle{10, 5}
	fmt.Println("면적:", rect.Area())  // 50
}
```

## 프로그래밍에서 구조체의 역할

구조체는 **응집도(Cohesion)**를 높이는 핵심 도구입니다.

### 응집도란?

관련된 요소들을 하나로 묶는 정도를 의미합니다.

**응집도를 높이는 도구들:**

1. **함수**: 관련 코드 블록을 묶음
   ```go
   func calculateAverage(scores []int) float64 {
       // 평균 계산 로직
   }
   ```

2. **배열**: 같은 타입의 데이터를 묶음
   ```go
   scores := [5]int{90, 85, 88, 92, 87}
   ```

3. **구조체**: 관련된 데이터를 묶음
   ```go
   type Student struct {
       Name   string
       Scores []int
       Average float64
   }
   ```

### 구조체의 장점

```go
// 구조체 없이 (응집도 낮음)
func PrintUserInfo(name string, id string, age int, email string) {
    // ...
}

// 구조체 사용 (응집도 높음)
type User struct {
    Name  string
    ID    string
    Age   int
    Email string
}

func PrintUserInfo(user User) {
    // ...
}
```

**장점:**
- 관련 데이터를 논리적으로 그룹화
- 코드 가독성 향상
- 유지보수 용이
- 재사용성 증가
- 실세계 개체를 코드로 모델링

## 구조체 활용 팁

### 1. 태그(Tag) 사용

구조체 필드에 메타데이터를 추가할 수 있습니다:

```go
type User struct {
    Name  string `json:"name"`
    Email string `json:"email" validate:"required,email"`
    Age   int    `json:"age" validate:"min=0,max=150"`
}
```

JSON 인코딩/디코딩, 유효성 검사 등에 활용됩니다.

### 2. 익명 구조체

일회성 데이터 구조가 필요할 때 유용합니다:

```go
config := struct {
    Host string
    Port int
}{
    Host: "localhost",
    Port: 8080,
}
```

### 3. 빈 구조체

메모리를 차지하지 않는 특별한 구조체:

```go
type Empty struct{}

var e Empty
fmt.Println(unsafe.Sizeof(e))  // 0
```

세트(Set) 구현이나 시그널 전용 채널에 활용됩니다.

## 정리
구조체는 Go 프로그래밍의 핵심입니다. 실세계의 개체를 코드로 표현하는 가장 기본적인 도구입니다!