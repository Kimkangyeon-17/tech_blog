# Go 언어 문자열

문자열은 프로그래밍에서 가장 많이 사용하는 데이터 타입 중 하나입니다. Go의 문자열은 독특한 특징들을 가지고 있습니다.

## 문자열 선언

Go의 문자열 타입은 `string`이며, 두 가지 방법으로 표현할 수 있습니다.

### 1. 큰따옴표 ("") - 해석 문자열

특수 문자가 해석됩니다.

```go
package main

import "fmt"

func main() {
	str1 := "Hello\t'World'\n"
	fmt.Println(str1)
}
```

실행 결과:

```bash
Hello	'World'

```

**특수 문자가 동작:**
- `\t`: 탭
- `\n`: 줄바꿈
- `\'`: 작은따옴표
- `\"`: 큰따옴표

### 2. 백쿼트 (`` ` ` ``) - 원시 문자열

특수 문자가 그대로 출력됩니다.

```go
package main

import "fmt"

func main() {
	str2 := `Go is "awesome"!\nGo is simple and\t'powerful'`
	fmt.Println(str2)
}
```

실행 결과:

```bash
Go is "awesome"!\nGo is simple and\t'powerful'
```

**특수 문자가 동작하지 않음**

### 여러 줄 문자열

백쿼트를 사용하면 여러 줄 문자열을 쉽게 작성할 수 있습니다.

```go
package main

import "fmt"

func main() {
	// 큰따옴표: \n 필요
	poet1 := "죽는 날까지 하늘을 우러러\n한 점 부끄럼이 없기를,\n잎새에 이는 바람에도\n나는 괴로웠다.\n"

	// 백쿼트: 그대로 작성
	poet2 := `죽는 날까지 하늘을 우러러
한 점 부끄럼이 없기를,
잎새에 이는 바람에도
나는 괴로웠다.`

	fmt.Println(poet1)
	fmt.Println(poet2)
}
```

실행 결과:

```bash
죽는 날까지 하늘을 우러러
한 점 부끄럼이 없기를,
잎새에 이는 바람에도
나는 괴로웠다.

죽는 날까지 하늘을 우러러
한 점 부끄럼이 없기를,
잎새에 이는 바람에도
나는 괴로웠다.
```

**백쿼트의 장점:**
- 여러 줄 문자열 작성 편리
- JSON, SQL, HTML 등의 템플릿 작성에 유용
- 이스케이프 처리 불필요

## UTF-8 문자 인코딩

Go 언어는 **UTF-8**을 표준 문자 인코딩으로 사용합니다.

### UTF-8의 특징

UTF-8은 Go 언어 창시자인 **롭 파이크(Rob Pike)**와 **켄 톰슨(Ken Thompson)**이 고안한 가변 길이 인코딩입니다.

**인코딩 비교:**

| 문자 종류 | UTF-8 | UTF-16 |
|-----------|-------|--------|
| 영문자, 숫자 | 1바이트 | 2바이트 |
| 한글, 중국어 | 3바이트 | 2바이트 |
| 이모지 | 4바이트 | 4바이트 |

**UTF-8의 장점:**
- 영문 위주 텍스트에서 메모리 절약
- ASCII와 호환
- 바이트 순서 문제 없음

### rune 타입으로 한 문자 담기

`rune` 타입은 유니코드 코드 포인트를 저장하는 타입입니다.

```go
type rune = int32  // rune은 int32의 별칭
```

```go
package main

import "fmt"

func main() {
	var char rune = '한'

	fmt.Printf("타입: %T\n", char)
	fmt.Printf("정수값: %d\n", char)
	fmt.Printf("문자: %c\n", char)
}
```

실행 결과:

```bash
타입: int32
정수값: 54620
문자: 한
```

**rune의 특징:**
- 작은따옴표(`'`)로 표현
- 한 문자의 유니코드 값을 저장
- int32 타입 (4바이트)

## 문자열 길이

### len()으로 바이트 수 확인

`len()` 함수는 **바이트 수**를 반환합니다.

```go
package main

import "fmt"

func main() {
	str1 := "가나다라마"  // 한글: 각 3바이트
	str2 := "abcde"      // 영문: 각 1바이트

	fmt.Printf("len(str1) = %d\n", len(str1))
	fmt.Printf("len(str2) = %d\n", len(str2))
}
```

실행 결과:

```bash
len(str1) = 15
len(str2) = 5
```

**결과 분석:**
- 한글 5글자: 5 × 3 = 15바이트
- 영문 5글자: 5 × 1 = 5바이트

### []rune 변환으로 글자 수 확인

실제 글자 수를 알려면 `[]rune`으로 변환해야 합니다.

```go
package main

import "fmt"

func main() {
	str1 := "가나다라마"
	str2 := "abcde"

	// 바이트 수
	fmt.Printf("len(str1) = %d바이트\n", len(str1))
	fmt.Printf("len(str2) = %d바이트\n", len(str2))

	// 글자 수
	fmt.Printf("글자 수(str1) = %d글자\n", len([]rune(str1)))
	fmt.Printf("글자 수(str2) = %d글자\n", len([]rune(str2)))
}
```

실행 결과:

```bash
len(str1) = 15바이트
len(str2) = 5바이트
글자 수(str1) = 5글자
글자 수(str2) = 5글자
```

### rune 슬라이스와 문자열 변환

```go
package main

import "fmt"

func main() {
	str := "Hello World"
	
	// rune 슬라이스 생성
	runes := []rune{72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100}

	fmt.Println(str)
	fmt.Println(string(runes))
}
```

실행 결과:

```bash
Hello World
Hello World
```

### string과 []byte 상호 변환

`string`과 `[]byte`는 상호 변환이 가능합니다.

```go
str := "Hello"
bytes := []byte(str)  // string → []byte
str2 := string(bytes) // []byte → string

fmt.Println(bytes)    // [72 101 108 108 111]
fmt.Println(str2)     // Hello
```

## 문자열 순회

문자열을 순회하는 세 가지 방법이 있습니다.

### 1. 인덱스를 사용한 바이트 단위 순회

```go
package main

import "fmt"

func main() {
	str := "Hello 월드!"

	for i := 0; i < len(str); i++ {
		fmt.Printf("타입:%T 값:%d 문자:%c\n", str[i], str[i], str[i])
	}
}
```

실행 결과:

```bash
타입:uint8 값:72 문자:H
타입:uint8 값:101 문자:e
타입:uint8 값:108 문자:l
타입:uint8 값:108 문자:l
타입:uint8 값:111 문자:o
타입:uint8 값:32 문자: 
타입:uint8 값:236 문자:ì
타입:uint8 값:155 문자:
타입:uint8 값:148 문자:
타입:uint8 값:235 문자:ë
타입:uint8 값:147 문자:
타입:uint8 값:156 문자:
타입:uint8 값:33 문자:!
```

**문제점:** 한글이 깨집니다! (바이트 단위로 읽기 때문)

### 2. []rune 변환 후 한 글자씩 순회

```go
package main

import "fmt"

func main() {
	str := "Hello 월드!"
	arr := []rune(str)

	for i := 0; i < len(arr); i++ {
		fmt.Printf("타입:%T 값:%d 문자:%c\n", arr[i], arr[i], arr[i])
	}
}
```

실행 결과:

```bash
타입:int32 값:72 문자:H
타입:int32 값:101 문자:e
타입:int32 값:108 문자:l
타입:int32 값:108 문자:l
타입:int32 값:111 문자:o
타입:int32 값:32 문자: 
타입:int32 값:50900 문자:월
타입:int32 값:46300 문자:드
타입:int32 값:33 문자:!
```

**정상 출력!**

### 3. range 키워드로 한 글자씩 순회 (권장)

```go
package main

import "fmt"

func main() {
	str := "Hello 월드!"

	for _, v := range str {
		fmt.Printf("타입:%T 값:%d 문자:%c\n", v, v, v)
	}
}
```

실행 결과:

```bash
타입:int32 값:72 문자:H
타입:int32 값:101 문자:e
타입:int32 값:108 문자:l
타입:int32 값:108 문자:l
타입:int32 값:111 문자:o
타입:int32 값:32 문자: 
타입:int32 값:50900 문자:월
타입:int32 값:46300 문자:드
타입:int32 값:33 문자:!
```

**range의 장점:**
- 자동으로 UTF-8 디코딩
- 간결한 코드
- 가장 권장되는 방법

## 문자열 연산

### 문자열 합치기

`+`와 `+=` 연산자로 문자열을 연결할 수 있습니다.

```go
package main

import "fmt"

func main() {
	str1 := "Hello"
	str2 := "World"

	str3 := str1 + " " + str2
	fmt.Println(str3)

	str1 += " " + str2
	fmt.Println(str1)
}
```

실행 결과:

```bash
Hello World
Hello World
```

### 문자열 비교

```go
package main

import "fmt"

func main() {
	str1 := "Hello"
	str2 := "Hell"
	str3 := "Hello"

	fmt.Printf("%s == %s: %v\n", str1, str2, str1 == str2)
	fmt.Printf("%s != %s: %v\n", str1, str2, str1 != str2)
	fmt.Printf("%s == %s: %v\n", str1, str3, str1 == str3)
}
```

실행 결과:

```bash
Hello == Hell: false
Hello != Hell: true
Hello == Hello: true
```

### 문자열 대소 비교

사전식 순서로 비교합니다.

```go
package main

import "fmt"

func main() {
	str1 := "BBB"
	str2 := "aaaaAAA"
	str3 := "BBAD"
	str4 := "ZZZ"

	fmt.Printf("%s > %s: %v\n", str1, str2, str1 > str2)
	fmt.Printf("%s < %s: %v\n", str1, str3, str1 < str3)
	fmt.Printf("%s <= %s: %v\n", str1, str4, str1 <= str4)
}
```

실행 결과:

```bash
BBB > aaaaAAA: false
BBB < BBAD: false
BBB <= ZZZ: true
```

**비교 규칙:**
- 대문자가 소문자보다 작음 (ASCII 코드 순)
- 바이트 단위로 비교
- 'A' (65) < 'Z' (90) < 'a' (97) < 'z' (122)

## 문자열 내부 구조

### StringHeader 구조체

Go의 문자열은 내부적으로 다음과 같은 구조를 가집니다:

```go
type StringHeader struct {
	Data uintptr  // 문자열 데이터의 시작 주소
	Len  int      // 문자열의 길이 (바이트)
}
```

**구조 설명:**
- **Data**: 실제 문자 데이터가 있는 메모리 주소
- **Len**: 문자열의 바이트 길이

### 문자열 대입 시 동작

```go
package main

import (
	"fmt"
	"unsafe"
)

type StringHeader struct {
	Data uintptr
	Len  int
}

func main() {
	str1 := "Hello World!"
	str2 := str1

	header1 := (*StringHeader)(unsafe.Pointer(&str1))
	header2 := (*StringHeader)(unsafe.Pointer(&str2))

	fmt.Println(header1)  // &{4965497 12}
	fmt.Println(header2)  // &{4965497 12}
}
```

실행 결과:

```bash
&{4965497 12}
&{4965497 12}
```

**중요:** 두 문자열이 **같은 데이터 주소**를 가리킵니다!

```
str1과 str2는 같은 문자열 데이터를 공유
→ 메모리 효율적
→ 하지만 불변성이 보장되어야 안전
```

## 문자열은 불변(Immutable)

Go의 문자열은 **불변(immutable)**입니다. 한번 생성되면 변경할 수 없습니다.

### 문자열 변경 시도

```go
str := "Hello"
// str[0] = 'h'  // 컴파일 에러!
```

### string과 []byte의 메모리 주소 차이

```go
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	var str string = "Hello World"
	var slice []byte = []byte(str)  // 새로운 메모리에 복사

	fmt.Printf("str:   %p\n", unsafe.StringData(str))
	fmt.Printf("slice: %p\n", unsafe.SliceData(slice))
}
```

실행 결과:

```bash
str:   0x4be0b4
slice: 0xc000012050
```

**다른 주소!** → `[]byte` 변환 시 새로운 메모리에 복사됩니다.

### 문자열 합산과 메모리

```go
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	var str string = "Hello"
	add1 := unsafe.StringData(str)

	str += " World"
	add2 := unsafe.StringData(str)

	str += " Welcome!"
	add3 := unsafe.StringData(str)

	fmt.Println(str)
	fmt.Printf("add1: %p\n", add1)
	fmt.Printf("add2: %p\n", add2)
	fmt.Printf("add3: %p\n", add3)
}
```

실행 결과:

```bash
Hello World Welcome!
add1: 0x4bd4c6
add2: 0xc000012050
add3: 0xc00001a018
```

**중요:** 문자열을 합칠 때마다 **새로운 메모리**에 할당됩니다!

```
"Hello" → 메모리 A
"Hello World" → 메모리 B (새로 할당)
"Hello World Welcome!" → 메모리 C (새로 할당)
```

## 효율적인 문자열 조작

### strings.Builder 사용 (권장)

문자열을 여러 번 합칠 때는 `strings.Builder`를 사용하는 것이 효율적입니다.

```go
package main

import (
	"fmt"
	"strings"
)

func ToUpper1(str string) string {
	var rst string
	for _, c := range str {
		if c >= 'a' && c <= 'z' {
			rst += string('A' + (c - 'a'))  // 매번 새 메모리 할당
		} else {
			rst += string(c)
		}
	}
	return rst
}

func ToUpper2(str string) string {
	var builder strings.Builder
	for _, c := range str {
		if c >= 'a' && c <= 'z' {
			builder.WriteRune('A' + (c - 'a'))  // 효율적
		} else {
			builder.WriteRune(c)
		}
	}
	return builder.String()
}

func main() {
	var str string = "Hello World"

	fmt.Println(ToUpper1(str))
	fmt.Println(ToUpper2(str))
}
```

실행 결과:

```bash
HELLO WORLD
HELLO WORLD
```

### 성능 비교

| 방법 | 메모리 할당 횟수 | 성능 |
|------|-----------------|------|
| `+= 연산자` | 문자마다 1회 | 느림 |
| `strings.Builder` | 버퍼 확장 시에만 | 빠름 |

**strings.Builder의 장점:**
- 내부 버퍼 사용
- 메모리 재할당 최소화
- 성능 향상

## 문자열 불변 원칙의 이유

문자열이 불변이어야 하는 이유는 **안전성**과 **효율성** 때문입니다.

### 1. 안전성

```go
func ProcessString(s string) {
	// s가 불변이므로 안심하고 사용 가능
	fmt.Println(s)
}

str := "Hello"
ProcessString(str)
fmt.Println(str)  // "Hello" - 변경 걱정 없음
```

### 2. 메모리 공유

```go
str1 := "Hello"
str2 := str1  // 같은 메모리를 안전하게 공유
str3 := "Hello"  // 같은 리터럴은 재사용 가능
```

### 3. 맵 키로 안전

```go
m := make(map[string]int)
key := "test"
m[key] = 100
// key가 변경되지 않으므로 맵이 안전
```

**만약 불변이 아니라면:**
- 문자열 공유 시 의도치 않은 변경 가능
- 맵의 키가 변경되어 데이터 손실 가능
- 동시성 문제 발생 가능

## 실용적인 문자열 처리

### strings 패키지 활용

```go
import "strings"

// 문자열 포함 여부
strings.Contains("Hello World", "World")  // true

// 문자열 분리
strings.Split("a,b,c", ",")  // []string{"a", "b", "c"}

// 문자열 결합
strings.Join([]string{"a", "b", "c"}, ",")  // "a,b,c"

// 공백 제거
strings.TrimSpace("  hello  ")  // "hello"

// 대소문자 변환
strings.ToUpper("hello")  // "HELLO"
strings.ToLower("HELLO")  // "hello"
```

## 정리
문자열은 Go 프로그래밍에서 가장 자주 사용하는 타입입니다. 특히 UTF-8과 불변성을 이해하면 효율적이고 안전한 코드를 작성할 수 있습니다!