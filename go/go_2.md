# Go 언어 변수

Go 언어의 변수에 대해 알아보고자 합니다.

## 변수란?

변수는 값을 저장하는 메모리 공간을 가리키는 이름입니다.
프로그램에서 변수를 통해 데이터를 저장하고, 연산하고, 조작할 수 있습니다.

## 기본 실습

다음으로 변수에 값을 할당한 후 출력하는 예제 코드를 보겠습니다.

먼저 ex4.1 폴더를 만들어준 이후 ex4.1.go 파일을 생성합니다.

```go
package main

import "fmt"

func main() {
	var a int = 10
	var msg string = "Hello Variable"

	a = 20
	msg = "Good morning"
	fmt.Println(msg, a)
}
```

이후 다음과 같은 명령어를 순서대로 입력합니다.

```bash
go mod init goprojects/ex4.1
go build
./ex4.1.exe
```

위와 같은 명령어를 입력하면 go.mod와 ex4.1.exe 파일이 생성되며 아래와 같은 결과를 보여줍니다.

```bash
Good morning 20
```

**코드 설명:**
a와 msg는 이미 데이터 타입이 선언되었기 때문에 재할당할 때 데이터 타입을 다시 선언해줄 필요가 없습니다.

## 변수의 4가지 속성

변수는 다음과 같은 4가지 속성을 가집니다:

- **이름**: 변수를 식별하는 이름
- **값**: 변수에 저장된 실제 데이터
- **주소**: 메모리에서 변수가 저장된 위치
- **타입**: 변수가 저장할 수 있는 데이터의 종류

### Go 언어의 데이터 타입

#### 숫자 타입
- **uint**: 부호가 없는 정수 (양수만)
- **int**: 부호가 있는 정수 (음수, 양수)
- **float32/float64**: 실수 (소수점이 있는 수)
- **byte**: uint8과 같음 (0~255)
- **rune**: 문자 하나를 표현, int32와 같음

#### 기타 타입
- **bool**: true나 false 값을 가지는 변수
- **string**: 문자열
- **배열**: 고정 크기의 데이터 집합 `[5]int`
- **슬라이스**: 크기가 가변적인 배열 `[]int`
- **구조체**: 여러 데이터를 묶어서 새로운 타입 생성
- **포인터**: 메모리 주소를 저장하는 변수
- **함수 타입**: 함수를 변수에 저장
- **맵**: 키-값 쌍으로 데이터 저장 `map[string]int`
- **인터페이스**: 메서드의 집합을 정의
- **채널**: 고루틴 간 데이터 통신에 사용
- **별칭 타입**: 기존 타입에 새로운 이름을 부여

## 변수 선언 방법

Go에서는 4가지 방법으로 변수를 선언할 수 있습니다:

```go
var a int = 10    // 완전한 형태

var a int         // 초기값 생략 가능, 타입의 기본값으로 초기화

var a = 10        // 타입 생략 가능, 초기값의 타입으로 자동 결정

a := 10           // 짧은 선언문 (함수 내부에서만 사용 가능)
```

### 변수 선언 실습

```go
package main

import "fmt"

func main() {
	var a int = 3    // 완전한 선언
	var b int        // 타입만 선언, 기본값 0
	var c = 4        // 타입 추론
	d := 5           // 짧은 선언문
	var e = "hello"  // 문자열 타입 추론
	f := 3.14        // 실수 타입 추론

	fmt.Println(a, b, c, d, e, f)
}
```

위 파일을 build 후 실행시키면 `3 0 4 5 hello 3.14`가 나오는 것을 확인할 수 있습니다.

### 타입별 기본값

변수를 선언만 하고 초기값을 주지 않으면 다음과 같은 기본값이 할당됩니다:

- **모든 정수 타입**: 0
- **모든 실수 타입**: 0.0
- **불리언**: false
- **문자열**: "" (빈 문자열)
- **포인터, 슬라이스, 맵, 채널, 함수, 인터페이스**: nil

## 타입 변환

Go에서는 연산을 할 때 **각 항목의 타입이 반드시 같아야** 합니다. 타입이 다르면 명시적으로 타입 변환을 해야 합니다.

### 타입 변환 실습

```go
package main

import "fmt"

func main() {
	a := 3              // int
	var b float64 = 3.5 // float64

	var c int = int(b)  // float64를 int로 변환

	// d := a * b       // 에러! int와 float64는 타입이 달라서 연산 불가
	d := float64(a) * b // int를 float64로 변환 후 연산

	var e int64 = 7
	// f := a * e       // 에러! int와 int64는 서로 다른 타입
	f := a * int(e)     // int64를 int로 변환 후 연산

	fmt.Println(a, b, c, d, e, f)
}
```

위 파일을 build 후 실행시키면 `3 3.5 3 10.5 7 21`가 출력되는 것을 볼 수 있습니다.

### 타입 변환 시 주의사항

```go
package main

import "fmt"

func main() {
	var a int16 = 3456  // int16 타입 (2바이트 정수)
	var b int8 = int8(a) // int16을 int8로 변환

	fmt.Println(a, b)
}
```

위 코드를 build하여 실행하면 `3456 -128`과 같은 결과를 볼 수 있습니다.

**오류 발생 이유**

- int16은 -32,768 ~ 32,767의 값을 가질 수 있습니다 (2바이트)
- int8은 -128 ~ 127의 값을 가질 수 있습니다 (1바이트)
- 3456은 int8의 범위를 벗어나므로 데이터 손실이 발생합니다
- 이를 **오버플로우(Overflow)**라고 합니다

**주의:** 큰 타입에서 작은 타입으로 변환할 때는 항상 데이터 손실 가능성을 고려해야 합니다.

## 변수의 스코프 (범위)

변수가 선언되는 위치에 따라 변수가 사용할 수 있는 범위가 달라집니다.

### 스코프 실습

```go
package main

import "fmt"

var g int = 10 // 패키지 전역 변수 (어디서든 접근 가능)

func main() {
	var m int = 20 // 함수 지역 변수
	
	{
		var s int = 50 // 블록 지역 변수
		fmt.Println(m, s, g) // 모든 변수 접근 가능
	}

	// m = s + 20 // 에러! s는 블록을 벗어나서 접근 불가
	fmt.Println(m, g) // m과 g만 접근 가능
}
```

**스코프 규칙:**
- **전역 변수**: 패키지 전체에서 접근 가능
- **함수 지역 변수**: 해당 함수 내에서만 접근 가능  
- **블록 지역 변수**: 해당 블록({}) 내에서만 접근 가능

## 부동소수점의 정밀도 문제

실수 연산에서는 정밀도 문제가 발생할 수 있습니다.

### 부동소수점 정밀도 실습

```go
package main

import "fmt"

func main() {
	var a float32 = 1234.523
	var b float32 = 3456.123
	var c float32 = a * b
	var d float32 = c * 3

	fmt.Println("a =", a)
	fmt.Println("b =", b)
	fmt.Println("c =", c)
	fmt.Println("d =", d)
}
```

위 코드를 build 후 실행시키면:

```bash
a = 1234.523
b = 3456.123
c = 4.266663e+06
d = 1.2799989e+07
```

**결과 분석:**
- 실제 계산: 1234.523 × 3456.123 = 4,266,663.334329
- float32 결과: 4.266663e+06 (4,266,663)
- 소수점 뒤 .334329 부분에서 오차가 발생했습니다

**오류 발생 이유**
- float32는 32비트로 실수를 표현하므로 정밀도에 한계가 있습니다
- 연산을 거듭할수록 오차가 누적됩니다
- 더 높은 정밀도가 필요하면 float64를 사용하는 것이 좋습니다

**개선된 예시:**
```go
var a float64 = 1234.523  // float64 사용
var b float64 = 3456.123
```

## 정리

**오늘 배운 핵심 내용:**
- 변수는 이름, 값, 주소, 타입의 4가지 속성을 가집니다
- Go는 다양한 변수 선언 방법을 제공합니다 (var, :=)
- 타입이 다른 변수는 명시적 변환 후 연산해야 합니다
- 타입 변환 시 데이터 손실 주의가 필요합니다
- 변수의 스코프를 이해하고 적절히 활용해야 합니다
- 부동소수점 연산에서는 정밀도 문제를 고려해야 합니다

다음 포스트에서는 Go의 상수(const)와 함수에 대해 알아보겠습니다!

go, golang, Google, gopher, Programming Language, 고, 고언어, 프로그래밍언어