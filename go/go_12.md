# Go 언어 포인터

포인터는 메모리의 주소를 다루는 강력한 도구입니다. Go의 포인터를 제대로 이해하면 효율적인 프로그램을 작성할 수 있습니다.

## 포인터란?

**포인터(Pointer)**는 메모리 주소를 값으로 갖는 타입입니다.

**핵심 개념:**
- **변수**: 값을 저장하는 메모리 공간
- **메모리 주소**: 그 공간이 어디에 있는지를 나타내는 주소
- **포인터**: 그 주소를 저장하는 변수

### 포인터 변수 선언

```go
var p *int  // int 타입을 가리키는 포인터
```

**문법:**
- `*타입`: 해당 타입을 가리키는 포인터
- `*int`: int를 가리키는 포인터
- `*string`: string을 가리키는 포인터

### 포인터 기본 연산자

**& (주소 연산자):**
- 변수의 메모리 주소를 반환
- `&변수`

**\* (역참조 연산자):**
- 포인터가 가리키는 메모리의 값에 접근
- `*포인터`

### 포인터 기본 예제

```go
package main

import "fmt"

func main() {
	var a int = 500
	var p *int

	p = &a  // a의 주소를 p에 저장

	fmt.Printf("a의 값: %d\n", a)
	fmt.Printf("a의 주소: %p\n", &a)
	fmt.Printf("p의 값: %p\n", p)
	fmt.Printf("p가 가리키는 메모리의 값: %d\n", *p)

	*p = 100  // 포인터를 통해 값 변경
	fmt.Printf("a의 값: %d\n", a)
}
```

실행 결과:

```bash
a의 값: 500
a의 주소: 0xc000012050
p의 값: 0xc000012050
p가 가리키는 메모리의 값: 500
a의 값: 100
```

**동작 원리:**

```
메모리 상황:
주소 0xc000012050에 변수 a가 있고, 값은 500

1. p = &a
   → p에는 0xc000012050이 저장됨

2. *p = 100
   → 0xc000012050 주소의 값을 100으로 변경
   → a의 값도 100이 됨 (같은 메모리를 가리킴)
```

### 포인터 비교

포인터끼리 비교하면 **주소를 비교**합니다.

```go
package main

import "fmt"

func main() {
	var a int = 10
	var b int = 20

	var p1 *int = &a
	var p2 *int = &a
	var p3 *int = &b

	fmt.Printf("p1 == p2: %v\n", p1 == p2)  // 같은 주소
	fmt.Printf("p2 == p3: %v\n", p2 == p3)  // 다른 주소
}
```

실행 결과:

```bash
p1 == p2: true
p2 == p3: false
```

**비교 규칙:**
- 같은 변수를 가리키면 `true`
- 다른 변수를 가리키면 `false`
- 값이 같아도 주소가 다르면 `false`

### 포인터의 기본값: nil

초기화하지 않은 포인터의 값은 `nil`입니다.

```go
var p *int
fmt.Println(p)  // <nil>

if p == nil {
	fmt.Println("p는 아무것도 가리키지 않습니다")
}
```

**nil 포인터 주의사항:**

```go
var p *int
// *p = 10  // 런타임 에러! nil 포인터 역참조

// 올바른 사용
var a int
p = &a
*p = 10  // OK
```

**nil 체크 패턴:**

```go
if p != nil {
	// p가 유효한 메모리 주소를 가리킴
	fmt.Println(*p)
}
```

## 포인터를 사용하는 이유

Go에서 변수 대입이나 함수 인수 전달은 **항상 값을 복사**합니다.

### 문제 1: 메모리 낭비

큰 구조체를 복사하면 메모리가 낭비됩니다.

```go
type BigData struct {
	value int
	data  [1000000]int  // 매우 큰 배열
}

func ProcessData(arg BigData) {  // 전체 복사!
	// 약 8MB 복사
}
```

### 문제 2: 값 변경 불가

함수에서 원본 값을 변경할 수 없습니다.

### 포인터 없이 (값 복사)

```go
package main

import "fmt"

type Data struct {
	value int
	data  [200]int
}

func ChangeData(arg Data) {  // 복사본을 받음
	arg.value = 999
	arg.data[100] = 999
	// 복사본만 변경됨
}

func main() {
	var data Data

	ChangeData(data)  // data를 복사해서 전달
	fmt.Printf("value = %d\n", data.value)
	fmt.Printf("data[100] = %d\n", data.data[100])
}
```

실행 결과:

```bash
value = 0
data[100] = 0
```

**문제점:**
- Data 구조체(약 1.6KB)가 통째로 복사됨
- 원본은 변경되지 않음

### 포인터 사용 (주소 전달)

```go
package main

import "fmt"

type Data struct {
	value int
	data  [200]int
}

func ChangeData(arg *Data) {  // 포인터를 받음
	arg.value = 999
	arg.data[100] = 999
	// 원본을 직접 변경
}

func main() {
	var data Data

	ChangeData(&data)  // 주소를 전달
	fmt.Printf("value = %d\n", data.value)
	fmt.Printf("data[100] = %d\n", data.data[100])
}
```

실행 결과:

```bash
value = 999
data[100] = 999
```

**장점:**
- 주소만 복사 (8바이트만 복사)
- 원본을 직접 변경 가능
- 메모리 효율적
- 성능 향상

### 포인터 사용 비교표

| 특징 | 값 복사 | 포인터 전달 |
|------|---------|------------|
| 복사 크기 | 전체 구조체 | 8바이트 (주소) |
| 원본 변경 | 불가능 | 가능 |
| 메모리 | 많이 사용 | 적게 사용 |
| 성능 | 느림 (큰 데이터) | 빠름 |
| 안전성 | 높음 (독립적) | 낮음 (공유) |

## 인스턴스

**인스턴스(Instance)**는 메모리에 할당된 데이터의 실체를 말합니다.

### 인스턴스 개념

```go
type User struct {
	Name string
	Age  int
}

func main() {
	var u User       // 인스턴스 생성
	var p1 *User = &u
	var p2 *User = &u
	var p3 *User = &u
}
```

**핵심:**
- 인스턴스는 1개 (메모리에 User 하나)
- 포인터는 3개 (p1, p2, p3가 같은 인스턴스를 가리킴)
- 인스턴스 개수 ≠ 포인터 개수

### new() 내장 함수

`new()` 함수는 새로운 인스턴스를 생성하고 포인터를 반환합니다.

```go
// 두 방법은 동일
p1 := &User{}     // & 사용
p2 := new(User)   // new() 사용

p1.Name = "Alice"
p2.Name = "Bob"
```

**new()의 특징:**
- 메모리를 할당하고 포인터 반환
- 모든 필드를 기본값으로 초기화
- 간결한 표현

**초기값이 필요한 경우:**

```go
// & 사용 (초기값 지정 가능)
p1 := &User{Name: "Alice", Age: 30}

// new() 사용 (초기값 지정 후 설정)
p2 := new(User)
p2.Name = "Bob"
p2.Age = 25
```

## 가비지 컬렉터 (Garbage Collector)

메모리는 유한한 자원입니다. 사용하지 않는 메모리를 자동으로 해제하는 기능이 필요합니다.

### 가비지 컬렉션 동작

```go
func TestFunc() {
	u := &User{}  // 인스턴스 생성
	u.Age = 30
	fmt.Println(u)
}  // 함수 종료: u 포인터 사라짐 → 인스턴스도 GC 대상
```

**동작 원리:**
1. 함수가 끝나면 지역 변수 `u`가 사라짐
2. 인스턴스를 가리키는 포인터가 없어짐
3. 가비지 컬렉터가 해당 인스턴스를 수거
4. 메모리 해제

### 인스턴스가 유지되는 경우

```go
func CreateUser() *User {
	u := &User{Name: "Alice", Age: 30}
	return u  // 포인터를 반환
}

func main() {
	user := CreateUser()  // 외부에서 포인터를 받음
	fmt.Println(user)     // 인스턴스는 유지됨
}
```

**이유:** `user` 변수가 인스턴스를 가리키고 있어서 GC 대상이 아님

### 가비지 컬렉션의 장점

**다른 언어와 비교:**

| 언어 | 메모리 관리 방식 |
|------|-----------------|
| C/C++ | 수동 (malloc/free, new/delete) |
| Java | 자동 (GC) |
| Go | 자동 (GC) |

**Go의 GC 장점:**
- 메모리 누수 방지
- 개발자가 메모리 관리 부담 없음
- 안전한 프로그래밍

## 스택 메모리와 힙 메모리

프로그램은 두 종류의 메모리 영역을 사용합니다.

### 스택 메모리

**특징:**
- 함수 호출 시 생성, 종료 시 자동 해제
- 매우 빠름
- 크기 제한이 있음
- 함수 내부에서만 사용

```go
func Calculate() int {
	x := 10  // 스택에 할당
	y := 20  // 스택에 할당
	return x + y
}  // x, y 자동 해제
```

### 힙 메모리

**특징:**
- 동적으로 할당
- 함수가 끝나도 유지 가능
- 상대적으로 느림
- 크기 제한이 크거나 없음
- 가비지 컬렉션 필요

```go
func CreateUser() *User {
	u := &User{}  // 힙에 할당 (포인터 반환)
	return u
}  // u 포인터는 사라지지만 인스턴스는 힙에 유지
```

### 이스케이프 분석 (Escape Analysis)

Go 컴파일러는 **이스케이프 분석**을 통해 변수를 스택에 둘지 힙에 둘지 자동으로 결정합니다.

**스택에 할당되는 경우:**

```go
func Calculate() int {
	x := 10  // 함수 내부에서만 사용
	return x
}
```

**힙에 할당되는 경우:**

```go
func NewUser(name string, age int) *User {
	var u = User{name, age}
	return &u  // 포인터를 반환 → 힙으로 이스케이프
}

func main() {
	userPointer := NewUser("Alice", 23)
	fmt.Println(userPointer)
}
```

실행 결과:

```bash
&{Alice 23}
```

**이스케이프 분석 규칙:**
1. **함수 외부로 반환되는 포인터** → 힙
2. **크기가 큰 객체** → 힙
3. **함수 내부에서만 사용** → 스택

### 이스케이프 분석 확인하기

컴파일러가 어디에 할당하는지 확인할 수 있습니다:

```bash
go build -gcflags="-m" main.go
```

**출력 예시:**

```bash
./main.go:10:6: moved to heap: u
```

### 메모리 할당 비교

| 특징 | 스택 | 힙 |
|------|------|-----|
| 속도 | 매우 빠름 | 상대적으로 느림 |
| 크기 | 제한적 | 크거나 제한 없음 |
| 생명주기 | 함수 내부 | 프로그램 종료까지 |
| 관리 | 자동 (함수 종료 시) | GC 필요 |
| 사용 시기 | 지역 변수 | 외부 공유 데이터 |


## 포인터 사용 주의사항

### 1. nil 포인터 역참조

```go
var p *int
// fmt.Println(*p)  // 패닉! nil 포인터

// 안전한 사용
if p != nil {
	fmt.Println(*p)
}
```

### 2. 댕글링 포인터

Go는 가비지 컬렉션으로 자동 관리되므로 댕글링 포인터가 발생하지 않습니다.

### 3. 과도한 포인터 사용

```go
// 불필요한 포인터 사용
func Add(a *int, b *int) *int {
	result := *a + *b
	return &result
}

// 간단하게
func Add(a int, b int) int {
	return a + b
}
```

**포인터 사용 기준:**
- 큰 구조체를 전달할 때
- 원본을 수정해야 할 때
- nil 표현이 필요할 때

작은 값(int, bool 등)은 복사가 더 효율적일 수 있습니다.

## 정리
포인터는 Go 프로그래밍의 핵심 개념입니다. 올바르게 사용하면 효율적이고 강력한 프로그램을 작성할 수 있습니다!